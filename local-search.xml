<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>蒙特卡洛采样回溯计算V值</title>
    <link href="/2024/05/11/%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E9%87%87%E6%A0%B7%E5%9B%9E%E6%BA%AF%E8%AE%A1%E7%AE%97V%E5%80%BC/"/>
    <url>/2024/05/11/%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E9%87%87%E6%A0%B7%E5%9B%9E%E6%BA%AF%E8%AE%A1%E7%AE%97V%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="Monte-Carlo-Sampling-1947"><a href="#Monte-Carlo-Sampling-1947" class="headerlink" title="Monte Carlo Sampling (1947)"></a>Monte Carlo Sampling (1947)</h1><ol><li>我们把智能体放到环境的任意状态</li><li>从这个状态开始按照策略进行选择动作，并进入新的状态。</li><li>重复步骤 2，直到最终状态</li><li>我们从最终状态开始向前回溯:计算每个状态的 G 值。</li><li>重复 1-4 多次，然后平均每个状态的 G 值，这就是我们需要求的 V 值。<img src="/2024/05/11/%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E9%87%87%E6%A0%B7%E5%9B%9E%E6%BA%AF%E8%AE%A1%E7%AE%97V%E5%80%BC/%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E9%87%87%E6%A0%B7%E5%9B%9E%E6%BA%AF.png" class="" title="蒙特卡洛采样回溯"></li></ol><p>第一步，我们根据策略往前走，一直走到最后，期间我们什么都不用算，还需要记录每个状态转移，我们获得多少奖励r即可。</p><p>第二步，我们从终点往前走，一遍走一遍计算 G 值。G 值等于上一个状态的 G 值(记作G’),乘以一定的折扣(gamma),再加上r。  </p><blockquote><p><strong>折扣率</strong> 在强化学习中，有某些参数是人为主观制定不能推导，但在实际应用中却能解决问题，所以我们称这些参数为超参数，而折扣率就是一个超参数。与金融产品说的贴现率是类似的。我们计算价值，目的就是把未来很多步奖励，折算到当前节点。但未来n步的奖励的 10 点奖励，与当前的 10 点奖励是否完全等价呢?未必。所以我们人为地给未来的奖励一定的折扣，例如:0.9,0.8，然后在计算到当前的价值。  </p></blockquote><p>所以G值的意义在于，在一次游戏中，某个状态到最终状态的奖励总和(简单理解时科研忽略折扣值)  </p><img src="/2024/05/11/%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E9%87%87%E6%A0%B7%E5%9B%9E%E6%BA%AF%E8%AE%A1%E7%AE%97V%E5%80%BC/%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E9%87%87%E6%A0%B7%E5%9B%9E%E6%BA%AF2.png" class="" title="蒙特卡洛采样回溯2">  <p>当我们进行多次试验后，我们有可能会经过某个状态多次，通过回，也会有多个G.重复我们刚才说的，每一个G值，就是每次到最终状态获得的奖励总和。而V值，某个状态下，我们通过影分身到达最终状态，所有影分身获得的奖励的平均值。  </p><img src="/2024/05/11/%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E9%87%87%E6%A0%B7%E5%9B%9E%E6%BA%AF%E8%AE%A1%E7%AE%97V%E5%80%BC/%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E9%87%87%E6%A0%B7%E5%9B%9E%E6%BA%AF3.png" class="" title="蒙特卡洛采样回溯3">  <ol><li>G 的意义:在某个路径上，状态S到最终状态的总收获。</li><li>V和 G 的关系:V 是 G的平均数。</li></ol><p>到这里要注意一点:V和策略是相关的，那么在这里怎么体现呢?  </p><img src="/2024/05/11/%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E9%87%87%E6%A0%B7%E5%9B%9E%E6%BA%AF%E8%AE%A1%E7%AE%97V%E5%80%BC/%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E9%87%87%E6%A0%B7%E5%9B%9E%E6%BA%AF4.png" class="" title="蒙特卡洛采样回溯4">  <p>蒙地卡罗有一个比较大的缺点，就是每一次游戏，都需要先从头走到尾，再进行回溯更新。如果最终状态很难达到，可能每一次都要转很久很久才能更新一次 G 值。</p>]]></content>
    
    
    <categories>
      
      <category>强化学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>强化学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>马尔科夫链</title>
    <link href="/2024/05/11/%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E9%93%BE/"/>
    <url>/2024/05/11/%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E9%93%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="马尔可夫链"><a href="#马尔可夫链" class="headerlink" title="马尔可夫链"></a>马尔可夫链</h1><p>马尔可夫博弈（Markov Game）也被称为随机博弈。  </p><img src="/2024/05/11/%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E9%93%BE/%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E9%93%BE.png" class="" title="马尔科夫链">  <p>有三个重要的元素:S，A，R。我们分别来看一下，他们代表的是什么。然后大家就会明白，为什么马尔科夫链是一个很好很常用的模型。  </p><p>1.智能体在环境中，观察到状态(S)  </p><p>2.状态(S)被输入到智能体，智能体经过计算，选择动作(A);  </p><p>3.动作(A)使智能体进入另外一个状态(S)，并返回奖励(R)给智能体,重复以上步骤，一步一步创造马尔科夫链。  </p><p>4.智能体根据返回，调整自己的策略。  </p><p>所以你看，强化学习跟教孩子是一个道理: 孩子做了好事，必须给奖励;孩子做错事了必须惩罚。就这么简单!  </p><p>其中的不确定性:  </p><ol><li><p>“选择”的过程。<br>智能体“选择”会影响到下一个状态。比如state&#x2F;observation 一样，agent 对于 action 的选择也可能不同，这种不同动作之间的选择，我们称为智能体的策略。策略我们一般用Π表示。我们的任务就是找到一个策略，能够获得最多的奖励。  </p></li><li><p>环境的随机性。<br>这是智能体无法控制的，比如 action 一样但反馈回来新的 state&#x2F;observation 或reward 也可能有所不同。但马尔科夫链允许我们有不确定性的存在。</p></li></ol><p>所以，这种不确定性来自两个方面:1.智能体的行动选择(策略)。2.环境的不确定性。</p><h1 id="Q值和V值"><a href="#Q值和V值" class="headerlink" title="Q值和V值"></a>Q值和V值</h1><p>当智能体从一个状态S，这马可洛夫告诉我们:选择动作 A，会进入另外一个状态 S’同时，也会给智能体奖励 R。奖励既有正，也有负。正代表我们鼓励智能体在这个状态下继续这么做;负得话代表我们并不希望智能体这么做。在强化学习中，我们会用奖励 R作为智能体学习的引导，期望智能体获得尽可能多的奖励。 </p><p>但更多的时候，我们并不能单纯通过 R来衡量一个动作的好坏。我们必须用长远的眼光来看待问题。我们要把<strong>未来的奖励</strong>也计算到当前状态下，再进行决策。  </p><p>举例，就好比下棋，前期布局当中某一步的效果reward，并不能直接反应出它的作用再如中局弃子可能会使得当前reward 为负，但是或许可以带来未来更大的胜利!  </p><img src="/2024/05/11/%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E9%93%BE/alphago.png" class="" title="alphago">  <p>所以我们在做决策的时候，需要把眼光放远点，把未来的价值换到当前，才能做出选择。  </p><p>为了方便，我们希望可以有一种方法衡量 agent 做出每种选择的价值。这样，我如果通过方法未卜先知，以后的事情我也不用理了，agent 当前就能选择哪个动作价值更大，就选那个动作就可以了。</p><img src="/2024/05/11/%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E9%93%BE/%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E9%93%BE.png" class="" title="马尔科夫链">  <p><strong>评伦动作的价值，我们称为Q值:</strong> 它代表了智能体选择这个动作后，一直到最终状态奖励总和的期望;  </p><p><strong>评估状态的价值，我们称为V值:</strong> 它代表了智能体在这个状态下，一直到最终状态的奖励总和的期望。  </p><p>价值越高，表示我从当前状态到最终状态能获得的平均奖励将会越高。因为智能体的目标数是获取尽可能多的奖励，所以智能体在当前状态，只需要选择价值高的动作就可以了。</p><h2 id="V值"><a href="#V值" class="headerlink" title="V值"></a>V值</h2><p>假设现在需要求某个状态S的V值，那么我们可以这样：  </p><img src="/2024/05/11/%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E9%93%BE/%E5%BD%B1%E5%88%86%E8%BA%AB.png" class="" title="影分身">  <ol><li>我们从S点出发，并影分身出若干个自己;  </li><li>每个分身按照当前的策略 选择行为;</li><li>每个分身一直走到最终状态，并计算一路上获得的所有奖励总和;</li><li>我们计算每个影分身获得的平均值,这个平均值就是我们要求的 V值。</li></ol><p>用大白话总结就是:从某个状态，按照策略走到最终，最终获得奖励很多很多次，总和的平均值，就是V值。  </p><p>V 值是会根据不同的策略有所变化的!  </p><p>现在我们假设策略 采用平均策略[A1:50%,A2:50%],根据用影分身(如果是学霸直接求期望)，那么我们可以求得 V 值为 15  </p><img src="/2024/05/11/%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E9%93%BE/%E5%BD%B1%E5%88%86%E8%BA%AB%E8%A1%A81.png" class="" title="影分身表1">  <p>现在我们改变策略[A1:60%,A2:40%]，那么我们可以求得 V值为 14，变少了!</p><img src="/2024/05/11/%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E9%93%BE/%E5%BD%B1%E5%88%86%E8%BA%AB%E8%A1%A82.png" class="" title="影分身表2">  <h2 id="Q值"><a href="#Q值" class="headerlink" title="Q值"></a>Q值</h2><p>Q 值和 V值的概念是一致的，都是衡量在马可洛夫树上某一个节点的价值。只不过V值衡量的是状态节点的价值，而 Q值衡量的是动作节点的价值。<br>现在我们需要计算，某个状态 S0 下的一个动作 A的 Q 值:<br>1.我们就可以从 A 这个节点出发，使用影分身之术;<br>2.每个影分身走到最终状态,并记录所获得的奖励;<br>3.求取所有影分身获得奖励的平均值，这个平均值就是我们需要求的 Q 值。<br>用大白话总结就是:从某个状态选取动作 A，走到最终状态很多很多次;最终获得奖励总和的平均值，就是 Q值。  </p><ul><li>与V值不同，Q 值和策略并没有直接相关，而与环境的状态转移概率相关而环境的状态转移概率是不变的。</li></ul><h2 id="V值和Q值的关系"><a href="#V值和Q值的关系" class="headerlink" title="V值和Q值的关系"></a>V值和Q值的关系</h2><p>我们可以知道 Q 值和 V 值的意义相通的:</p><ol><li>都是马可洛夫树上的节点</li><li>价值评价的方式是一样的:<br> 从当前节点出发 - 一直走到最终节点 - 所有的奖励的期望值</li></ol><p>V 就是子节点的 Q的期望!但要注意 V值和策略相关。<br>Q 就是子节点的 V的期望!但要注意，记得把R计算在内。</p>]]></content>
    
    
    <categories>
      
      <category>强化学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>强化学习</tag>
      
      <tag>马尔科夫链</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>强化学习基础</title>
    <link href="/2024/05/11/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/05/11/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="强化学习基础"><a href="#强化学习基础" class="headerlink" title="强化学习基础"></a>强化学习基础</h1><h2 id="强化学习的任务"><a href="#强化学习的任务" class="headerlink" title="强化学习的任务"></a>强化学习的任务</h2><p>希望用强化学习的方式，使每个东西获得独立自主地完成某种任务的能力，这个东西被称为智能体。而智能体学习和工作的地方，称为环境。  </p><ul><li>所谓独立自主，就是智能体一旦启动，就不需要人指挥</li></ul><p>例如：扫地机器人自动清理，自动驾驶汽车自动驾驶。</p><p>智能体与环境的交互如图：  </p><img src="/2024/05/11/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/%E6%80%8E%E4%B9%88%E5%AD%A6%E4%B9%A0.png" class="" title="智能体与环境的交互">  <h2 id="A-actiopn-动作"><a href="#A-actiopn-动作" class="headerlink" title="A(actiopn)动作"></a>A(actiopn)动作</h2><p>动作就是智能体做出的具体行为。例如扫地机器人的移动，吸尘，喷水。无人驾驶汽车能够移动，加速，刹车。通信系统选择信道，选择调制编码方案等。  </p><p>动作空间就是该智能体能够做出的动作数量。<br>例如：智能体身处十字路口，方向就有四个，也就是动作有四个。</p><h2 id="R-reward-奖励"><a href="#R-reward-奖励" class="headerlink" title="R(reward)奖励"></a>R(reward)奖励</h2><p>当误码在某个状态下，完成动作。环境就会给我们<strong>反馈</strong>，告诉误码这个动作的效果如何。这种效果的数值表达，就是奖励。</p><p>其实这里的 reward 翻译为“反馈”可能更合适一点。因为反馈并不是完全正面的，也有负面。当奖励可以是正数，表示鼓励当前的行为;如果是负数负数，表示惩罚这种行为。当然也可以是 0。而奖励值的大小，表示鼓励的和惩罚的力度不同。  </p><p>奖励在强化学习中，起到了很关键的作用，我们会以奖励作为引导让智能体学习做能获得最多奖励的动作。  </p><p>例如:我需要训练机器人打乒乓球。机器人每次赢球，都可以加分;输球，就减分。这分数就表现了机器人的动作好坏。如果机器人希望获得更多的分数，就需要想办法赢球。  </p><p>又例如:无人驾驶汽车如果成功到达目标地点，那么可以获得奖励;但如果闯红灯，那么就会被扣除大量的奖励作为惩罚。如果无人驾驶汽车希望获得更多的分数，那么就必须在遵守交通规则的情况下，成功到达目标地点。  </p><p>注意，奖励的设定是主观的，也就是说我们为了智能体更好地学习工作，自己定的。所以大家可以看到，很多时候我们会对奖励进行一定的修正，这也是加速智能体学习的方法之一。  </p><p><strong>在通信系统中</strong>每选择一个信道或者调制编码方案，都会获得不同的信干噪比或者是误码率，表示了通信效能的好坏。  </p>]]></content>
    
    
    <categories>
      
      <category>强化学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>强化学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.C-运算符</title>
    <link href="/2024/04/26/2.C-%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <url>/2024/04/26/2.C-%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="2-运算符"><a href="#2-运算符" class="headerlink" title="2. 运算符"></a>2. 运算符</h1><p><strong>作用：</strong> 用于执行代码的运算  </p><table><thead><tr><th>运算符类型</th><th>作用</th></tr></thead><tbody><tr><td>算术运算符</td><td>用于处理四则运算</td></tr><tr><td>赋值运算符</td><td>用于将表达式的值赋给变量</td></tr><tr><td>比较运算符</td><td>用于表达式的比较，并返回一个真值或假值</td></tr><tr><td>逻辑运算符</td><td>用于根据表达式的值返回真值或假值</td></tr></tbody></table><h2 id="2-1-算术运算符"><a href="#2-1-算术运算符" class="headerlink" title="2.1 算术运算符"></a>2.1 算术运算符</h2><p><strong>作用：</strong> 用于处理四则运算</p><p>算术运算符包括以下符号：</p><table><thead><tr><th>运算符</th><th>术语</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td>+</td><td>正号</td><td>+3</td><td>3</td></tr><tr><td>-</td><td>负号</td><td>-3</td><td>-3</td></tr><tr><td>+</td><td>加</td><td>10 + 5</td><td>15</td></tr><tr><td>-</td><td>减</td><td>10- 5</td><td>5</td></tr><tr><td>*</td><td>乘</td><td>10 * 5</td><td>50</td></tr><tr><td>&#x2F;</td><td>除</td><td>10 &#x2F; 5</td><td>2</td></tr><tr><td>%</td><td>取模(取余)</td><td>10 % 3</td><td>1</td></tr><tr><td>++</td><td>前置递增</td><td>a&#x3D;2; b&#x3D;++a;</td><td>a&#x3D;3; b&#x3D;3;</td></tr><tr><td>++</td><td>后置递增</td><td>a&#x3D;2; b&#x3D;a++;</td><td>a&#x3D;3; b&#x3D;2;</td></tr><tr><td>–</td><td>前置递减</td><td>a&#x3D;2; b&#x3D;–a;</td><td>a&#x3D;1; b&#x3D;1;</td></tr><tr><td>–</td><td>后置递减</td><td>a&#x3D;2; b&#x3D;a–;</td><td>a&#x3D;1; b&#x3D;2;</td></tr></tbody></table><p><strong>示例1：</strong>  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//加减乘除</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-type">int</span> a1 = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b1 = <span class="hljs-number">3</span>;<br><br>    cout &lt;&lt; a1 + b1 &lt;&lt; endl;<br>    cout &lt;&lt; a1 - b1 &lt;&lt; endl;<br>    cout &lt;&lt; a1 * b1 &lt;&lt; endl;<br>    cout &lt;&lt; a1 / b1 &lt;&lt; endl;  <span class="hljs-comment">//两个整数相除结果依然是整数</span><br><br>    <span class="hljs-type">int</span> a2 = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b2 = <span class="hljs-number">20</span>;<br>    cout &lt;&lt; a2 / b2 &lt;&lt; endl; <br><br>    <span class="hljs-type">int</span> a3 = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b3 = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//cout &lt;&lt; a3 / b3 &lt;&lt; endl; //报错，除数不可以为0</span><br><br><br>    <span class="hljs-comment">//两个小数可以相除</span><br>    <span class="hljs-type">double</span> d1 = <span class="hljs-number">0.5</span>;<br>    <span class="hljs-type">double</span> d2 = <span class="hljs-number">0.25</span>;<br>    cout &lt;&lt; d1 / d2 &lt;&lt; endl;<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：在除法运算中，除数不能为0  </p></blockquote><p><strong>示例2：</strong>  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//取模</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-type">int</span> a1 = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b1 = <span class="hljs-number">3</span>;<br><br>    cout &lt;&lt; <span class="hljs-number">10</span> % <span class="hljs-number">3</span> &lt;&lt; endl;<br><br>    <span class="hljs-type">int</span> a2 = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b2 = <span class="hljs-number">20</span>;<br><br>    cout &lt;&lt; a2 % b2 &lt;&lt; endl;<br><br>    <span class="hljs-type">int</span> a3 = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b3 = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//cout &lt;&lt; a3 % b3 &lt;&lt; endl; //取模运算时，除数也不能为0，相除时除数不能为0</span><br><br>    <span class="hljs-comment">//两个小数不可以取模,两个小数可以相除</span><br>    <span class="hljs-type">double</span> d1 = <span class="hljs-number">3.14</span>;<br>    <span class="hljs-type">double</span> d2 = <span class="hljs-number">1.1</span>;<br><br>    <span class="hljs-comment">//cout &lt;&lt; d1 % d2 &lt;&lt; endl;</span><br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>示例3：</strong>  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//递增</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">//后置递增</span><br>    <span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    a++; <span class="hljs-comment">//等价于a = a + 1</span><br>    cout &lt;&lt; a &lt;&lt; endl; <span class="hljs-comment">// 11</span><br><br>    <span class="hljs-comment">//前置递增</span><br>    <span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;<br>    ++b;<br>    cout &lt;&lt; b &lt;&lt; endl; <span class="hljs-comment">// 11</span><br><br>    <span class="hljs-comment">//区别</span><br>    <span class="hljs-comment">//前置递增先对变量进行++，再计算表达式</span><br>    <span class="hljs-type">int</span> a2 = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b2 = ++a2 * <span class="hljs-number">10</span>;<br>    cout &lt;&lt; b2 &lt;&lt; endl;<br><br>    <span class="hljs-comment">//后置递增先计算表达式，后对变量进行++</span><br>    <span class="hljs-type">int</span> a3 = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> b3 = a3++ * <span class="hljs-number">10</span>;<br>    cout &lt;&lt; b3 &lt;&lt; endl;<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>运算符</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通信抗干扰策略_从评估到决策</title>
    <link href="/2024/04/25/%E9%80%9A%E4%BF%A1%E6%8A%97%E5%B9%B2%E6%89%B0%E7%AD%96%E7%95%A5_%E4%BB%8E%E8%AF%84%E4%BC%B0%E5%88%B0%E5%86%B3%E7%AD%96/"/>
    <url>/2024/04/25/%E9%80%9A%E4%BF%A1%E6%8A%97%E5%B9%B2%E6%89%B0%E7%AD%96%E7%95%A5_%E4%BB%8E%E8%AF%84%E4%BC%B0%E5%88%B0%E5%86%B3%E7%AD%96/</url>
    
    <content type="html"><![CDATA[<h1 id="1-评估（多属性决策问题）"><a href="#1-评估（多属性决策问题）" class="headerlink" title="1.评估（多属性决策问题）"></a>1.评估（多属性决策问题）</h1><h2 id="1-1-多属性决策问题研究意义"><a href="#1-1-多属性决策问题研究意义" class="headerlink" title="1.1 多属性决策问题研究意义"></a>1.1 多属性决策问题研究意义</h2><blockquote><p>随着紧急社会的不断发展，人们面临的决策形式和决策环境变得越来越复杂，无论政府的财政决策，还是企业的战略决策，都关乎其未来的发展。在决策科学领域存在一个重要分支，即多属性决策(multiple attribute decision making,MADM)。对多属性决策是由专家或评价者基于多个属性评估值，从多个备选方案中选出最优方案，以供决策者提供参考的过程。<br>常用的信息处理方法主要由两大类:一是传统的决策评价方法，如TOPSIS法、层次分析法(analytic hierarchy process,AHP)、灰色关联方法、投影分析法、VIKOR(vise kriterijumska optimizacijai kompromisino resenje)方法、ELECTRE(elimination et choice translation reality)方法等；二是信息集成算子，如简单的算术加权平均算子、几何加权算子，带有功能性的幂平均算子、BM算子、Heronian平均算子(Heronian mean,HM)以及MSM算子等。</p><blockquote><p>Q阶序对模糊多属性决策理论和方法_刘培德、王鹏  </p></blockquote></blockquote><p>我们需要这些评估方法(多属性决策方法)的原因，是为了解决决策形式和决策环境越来越复杂的问题，换句话说，也就是评估的指标越来越复杂，无法通过简单的方式来对一样事物进行评价。<br>评估的流程可以抽象为：1.选取指标 2. 获取指标参数 3. 综合计算。三步。<br><strong>举例</strong>：软科中国大学排名是一个利用层次分析法进行评估的例子。<br>该问题中决策者为选择学校的学生或老师，评价对象为学校。由于学校是一个综合的对象，存在很多方面的指标，决策者无法通过简单的一个或几个指标来判断一个大学的好坏，所以需要层次分析法，对指标进行分层和分别赋权，最后得到一个评分(评估结果)，最终得到一个大学的排序提供给决策者参考。<br>该问题中建立的层次分析法如图所示：  </p><img src="/2024/04/25/%E9%80%9A%E4%BF%A1%E6%8A%97%E5%B9%B2%E6%89%B0%E7%AD%96%E7%95%A5_%E4%BB%8E%E8%AF%84%E4%BC%B0%E5%88%B0%E5%86%B3%E7%AD%96/%E8%BD%AF%E7%A7%91%E8%AF%84%E4%BB%B7%E4%BD%93%E7%B3%BB.png" class="" width="400" title="软科评价体系">  <p>得到的评估结果如图：</p><img src="/2024/04/25/%E9%80%9A%E4%BF%A1%E6%8A%97%E5%B9%B2%E6%89%B0%E7%AD%96%E7%95%A5_%E4%BB%8E%E8%AF%84%E4%BC%B0%E5%88%B0%E5%86%B3%E7%AD%96/%E8%BD%AF%E7%A7%91%E8%AF%84%E4%BC%B0%E7%BB%93%E6%9E%9C.png" class="px" width="400" title="软科评估结果"> <blockquote><p>软科 2024软科中国大学排名  </p></blockquote><p>我们可以看出由于一个大学的评价存在多方面的多个指标，在不用任何方法的时候很难进行一个综合评价，所以需要层次分析法。<br>所以在面对多属性决策问题的时候，需要这些算法。</p><h2 id="1-2-数据链评估"><a href="#1-2-数据链评估" class="headerlink" title="1.2 数据链评估"></a>1.2 数据链评估</h2><p>数据链评估问题，带入到多属性决策模型中，就是面临数据链通信性能指标很多和很复杂的情况，需要一种数学算法来综合这些指标的参数，最后得到一个对多种抗干扰方案的评分和排序，给决策者提供参考。<br>那么我们需要思考的是，在数据链评估问题中是否满足这样的模型。<br>首先如果仅针对数据链抗干扰性能，狭义上我认为只需要得到数据链经过干扰前后的<strong>误码率性能</strong>就可以代表数据链抗干扰性能，那么在这种条件下就不需要使用任何数学算法。<br>在更广的意义上，也可以将其他的一些指标引入，以评估数据链的抗干扰性能，例如功率抑制度、频率抑制度、同步时间等，但是我认为大部分指标较为意义不明，功率的抑制或频率的抑制最终对数据链抗干扰能力的影响，也是体现在误码率上的，有误码率就足以代替掉这些指标。<br>我的结论是数据链抗干扰性能不具备建模成多属性决策模型的意义，也不需要数学算法来对其进行评估，因为误码率性能就足以代表数据链的抗干扰性能，事实上很多情况下(比如对数据链进行抗干扰技术的改进之后，也是用误码率性能的提升来体现该算法的好坏)也是就这么做的。<br>拓展到数据链评估，我认为就具有进行评估的意义了。</p><blockquote><p>对通信系统来说,衡量其通信性能的指标有很多,包括有效性、可靠性、适应性、标准性、可维护性以及经济性等,其中最重要的两个性能指标就是有效性和可靠性。</p><blockquote><p>基于强化学习的机载通信波形参数决策方法研究_赵思敏   </p></blockquote></blockquote><p>可以预见的，在拓展的评估对象的范围之后，可以选择的指标变多，可以选择有效性、可靠性、适应性、标准性、可维护性以及经济性等指标。基本满足多属性决策的建模要求，但是除了有效性和可靠性指标之外的指标，无法通过仿真获得，所以事实上能够选择的指标还是非常有限，所以我认为做数据链评估有一定的意义，但意义不大。</p><h2 id="1-3-评估方法"><a href="#1-3-评估方法" class="headerlink" title="1.3 评估方法"></a>1.3 评估方法</h2><p>已知数据链评估有一定意义，但意义不大，所以现有的研究中，该方向的文献比较少，只考虑数学算法，目前现有的数据链评估在层次分析法、TOPSIS法阶段。<br>现有的雷达效能评估处于TOPSIS法、直觉模糊评估阶段。<br>而多属性决策方法目前最新的研究进展是基于q阶模糊集的一些评估方法。引入q阶模糊集的原因是，例如误码率曲线在之前的评估中只用了一个参数代表其效果，这是不合理的，所以在q阶模糊集中，引入了隶属度和非隶属度两个参数来代表一条误码率曲线的性能。<br>然而无论使用什么评估方法，最终的结果都是几个评估值和一个排序，只能自己看图说明该评估方法的优越性，例如敏感性等，并且这样的评估最后在决策时只能列表查询，灵活性比较低。<strong>重要的是</strong>无论用什么数学方法，最后得到的都是一个评分值，难以说明算法的优势，最合理的是从原理上说明。</p><h1 id="2-数据链参数决策"><a href="#2-数据链参数决策" class="headerlink" title="2.数据链参数决策"></a>2.数据链参数决策</h1><h2 id="2-1-评估到决策"><a href="#2-1-评估到决策" class="headerlink" title="2.1 评估到决策"></a>2.1 评估到决策</h2><p>数据链评估的流程，是已经有很多抗干扰方案，例如不同的调制方式、编码方式、跳频策略等，然后分别对这些方案在不同的信道环境下进行评估，得到很多评分值，最终形成一个表格，在决策者面对不同的信道环境时，查表选择不同的抗干扰方案。这个查表操作在3GPP长期演进(LTE)系统中的AMC方案里面的调制编码方案的集合(MCS)有点类似，将在后续的章节里进行介绍。<br>上述介绍的多属性决策过程，实际上就是建立一个可供参考的表格的过程，这个过程中的决策者是人。这样的方法，最终的结果都是得到一个排序或者是表格，所有的方法几乎可以获得相同的效果，那么这个议题是否有意义就成为了问题。<br>我认为，为了达到选择最优数据链抗干扰方案的目的，并非一定要研究评估打分，可以直接考虑研究决策方法。<br>评估和决策的关系我们可以参考下图：  </p><img src="/2024/04/25/%E9%80%9A%E4%BF%A1%E6%8A%97%E5%B9%B2%E6%89%B0%E7%AD%96%E7%95%A5_%E4%BB%8E%E8%AF%84%E4%BC%B0%E5%88%B0%E5%86%B3%E7%AD%96/%E5%86%B3%E7%AD%96%E7%B3%BB%E7%BB%9F%E5%9B%BE.png" class="px" title="决策系统图"> <blockquote><p> 基于强化学习的机载通信波形参数决策方法研究_赵思敏  </p></blockquote><p>上图是自适应调制编码与扩频决策系统图，我们之前的评估，所做的工作就是图中的<strong>误码率通信性能计算</strong>部分，就是为了得到一个评分。该文章中直接用误码率性能来代表了数据链的性能，我们之前是在误码率性能之外又找了其他的指标，再利用数学方法得出一个评分，其实直接用误码率代表性能也是完全没问题的。<br>图中的指导决策部分是可以研究的方向。</p><h2 id="2-2-AMC"><a href="#2-2-AMC" class="headerlink" title="2.2 AMC"></a>2.2 AMC</h2><blockquote><p>传统的波形参数决策主要是对调制方式和编码速率的决策,可看作是AMC技术。在传统的AMC技术中,根据信道的状态信息(ChannelStateInformation,CSI),实时地调整调制方式和编码速率最大化系统吞吐量。AMC技术实现主要分为三个步骤:信道状态估计、信噪比估计、MCS切换方案。其中,信道状态估计主要是通过非盲信道、盲信道以及半盲信道估计等方法获取当前信道的估计参数;信噪比估计是将信道的状态信息映射为信噪比(SignalNoiseRatio,SNR)值,目前主要的研究方法有最大似然估计、基于谱估计、基于统计量估计等;MCS切换方案是指根据估计出来的信道状态信息和信噪比值来选择对应的调制方案,目前主要的研究方法有基于固定门限和基于门限调整。</p><blockquote><p>基于强化学习的D2D波形参数决策方法研究_谢霞  </p></blockquote></blockquote><p>AMC系统的框图如下所示  </p><img src="/2024/04/25/%E9%80%9A%E4%BF%A1%E6%8A%97%E5%B9%B2%E6%89%B0%E7%AD%96%E7%95%A5_%E4%BB%8E%E8%AF%84%E4%BC%B0%E5%88%B0%E5%86%B3%E7%AD%96/%E8%87%AA%E9%80%82%E5%BA%94%E8%B0%83%E5%88%B6%E7%BC%96%E7%A0%81%E7%B3%BB%E7%BB%9F%E6%A1%86%E5%9B%BE.png" class="" title="自适应调制编码系统框图"><p>传统的AMC方法使用的就是查表，也就是建立MCS的方法来进行自适应调制和编码的调整</p><p>多目标基础函数是一种层次分析法，可以用评估方法代替。</p>]]></content>
    
    
    <categories>
      
      <category>抗干扰策略</category>
      
    </categories>
    
    
    <tags>
      
      <tag>强化学习</tag>
      
      <tag>抗干扰策略</tag>
      
      <tag>评估</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.C++数据类型</title>
    <link href="/2024/04/24/1.C-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2024/04/24/1.C-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1. 数据类型"></a>1. 数据类型</h1><p>C++规定在创建一个变量或者常量时，必须要指定出相应的数据类型，否则无法给变量分配内存</p><h2 id="1-1-整型"><a href="#1-1-整型" class="headerlink" title="1.1 整型"></a>1.1 整型</h2><p><strong>作用</strong>：整型变量表示的是整数类型的数据</p><p>C++中能够表示整型的类型有以下几种方式，区别在于所占内存空间不同：</p><table><thead><tr><th>数据类型</th><th>占用空间</th><th>取值范围</th></tr></thead><tbody><tr><td>short(短整型)</td><td>2字节</td><td>(-2^15 ~ 2^15-1)</td></tr><tr><td>int(整型)</td><td>4字节</td><td>(-2^31 ~ 2^31-1)</td></tr><tr><td>long(长整形)</td><td>Windows为4字节，Linux为4字节(32位)，8字节(64位)</td><td>(-2^31 ~ 2^31-1)</td></tr><tr><td>long long(长长整形)</td><td>8字节</td><td>(-2^63 ~ 2^63-1)</td></tr></tbody></table><h2 id="1-2-sozeof关键字"><a href="#1-2-sozeof关键字" class="headerlink" title="1.2 sozeof关键字"></a>1.2 sozeof关键字</h2><p><strong>作用</strong>：利用sizeof关键字可以统计数据类型所占内存大小  </p><p><strong>语法</strong>：<code>sizeof( 数据类型 / 变量)</code>  </p><p><strong>示例</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;short 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">short</span>) &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;int 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;long 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">long</span>) &lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;long long 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">long</span> <span class="hljs-type">long</span>) &lt;&lt; endl;<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>整型结论：short &lt; int &lt;&#x3D; long &lt;&#x3D; long long  </p></blockquote><p><strong>问题</strong>：这里遇到了控制台输出中文乱码的问题，原因是控制台输出的字符格式没有被定义为UTF-8 编码<br><strong>解决方法</strong>：设置控制台输出为UTF-8 编码格式，具体操作如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-built_in">SetConsoleOutputCP</span>(CP_UTF8);  <span class="hljs-comment">// 设置控制台输出为 UTF-8 编码</span><br>   cout &lt;&lt; <span class="hljs-string">&quot;你好 &quot;</span>&lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-3-实型（浮点型）"><a href="#1-3-实型（浮点型）" class="headerlink" title="1.3 实型（浮点型）"></a>1.3 实型（浮点型）</h2><p><strong>作用</strong>：用于表示小数<br>浮点型变量分为两种：  </p><ol><li>单精度float</li><li>双精度double</li></ol><p>两者的区别在于表示的有效数字范围不同。  </p><table><thead><tr><th>数据类型</th><th>占用空间</th><th>有效数字范围</th></tr></thead><tbody><tr><td>float</td><td>4字节</td><td>7位有效数字</td></tr><tr><td>double</td><td>8字节</td><td>15～16位有效数字</td></tr><tr><td><strong>示例：</strong></td><td></td><td></td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-type">float</span> f1 = <span class="hljs-number">3.14f</span>;<br>    <span class="hljs-type">double</span> d1 = <span class="hljs-number">3.14</span>;<br><br>    cout &lt;&lt; f1 &lt;&lt; endl;<br>    cout &lt;&lt; d1&lt;&lt; endl;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;float  sizeof = &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(f1) &lt;&lt; endl;<span class="hljs-comment">//4字节</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;double sizeof = &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(d1) &lt;&lt; endl;<span class="hljs-comment">//8字节</span><br><br>    <span class="hljs-comment">//科学计数法</span><br>    <span class="hljs-type">float</span> f2 = <span class="hljs-number">3e2</span>; <span class="hljs-comment">// 3 * 10 ^ 2 </span><br>    cout &lt;&lt; <span class="hljs-string">&quot;f2 = &quot;</span> &lt;&lt; f2 &lt;&lt; endl;<br><br>    <span class="hljs-type">float</span> f3 = <span class="hljs-number">3e-2</span>;  <span class="hljs-comment">// 3 * 0.1 ^ 2</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;f3 = &quot;</span> &lt;&lt; f3 &lt;&lt; endl;<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-4-字符型"><a href="#1-4-字符型" class="headerlink" title="1.4 字符型"></a>1.4 字符型</h2><p><strong>作用:</strong> 字符型变量用于显示单个字符<br><strong>语法:</strong>  <code>char ch = &#39;a&#39;;</code></p><blockquote><p>注意1：在显示字符型变量时，用单引号将字符括起来，不要用双引号  </p></blockquote><blockquote><p>注意2：单引号内只能有一个字符，不可以是字符串</p></blockquote><ul><li>C和C++中字符型变量只占用1个字节。</li><li>字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII编码放入到存储单元</li></ul><p><strong>示例：</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>        <br>    <span class="hljs-type">char</span> ch = <span class="hljs-string">&#x27;a&#x27;</span>;<br>    cout &lt;&lt; ch &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>) &lt;&lt; endl;<br><br>    <span class="hljs-comment">//ch = &quot;abcde&quot;; //错误，不可以用双引号</span><br>    <span class="hljs-comment">//ch = &#x27;abcde&#x27;; //错误，单引号内只能引用一个字符</span><br><br>    cout &lt;&lt; (<span class="hljs-type">int</span>)ch &lt;&lt; endl;  <span class="hljs-comment">//查看字符a对应的ASCII码</span><br>    ch = <span class="hljs-number">97</span>; <span class="hljs-comment">//可以直接用ASCII给字符型变量赋值</span><br>    cout &lt;&lt; ch &lt;&lt; endl;<br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-5-转义字符"><a href="#1-5-转义字符" class="headerlink" title="1.5 转义字符"></a>1.5 转义字符</h2><p><strong>作用：</strong> 用于表示一些不能显示出来的ASCII字符<br>现阶段我们常用的转义字符有：<code> \n \\ \t</code>  </p><table><thead><tr><th>转义字符</th><th>含义</th><th>ASCII码值（十进制）</th></tr></thead><tbody><tr><td>\a</td><td>警报</td><td>007</td></tr><tr><td>\b</td><td>退格(BS) ，将当前位置移到前一列</td><td>008</td></tr><tr><td>\f</td><td>换页(FF)，将当前位置移到下页开头</td><td>012</td></tr><tr><td>\n</td><td>换行(LF) ，将当前位置移到下一行开头</td><td>010</td></tr><tr><td>\r</td><td>回车(CR) ，将当前位置移到本行开头</td><td>013</td></tr><tr><td>\t</td><td>水平制表(HT) （跳到下一个TAB位置）</td><td>009</td></tr><tr><td>\v</td><td>垂直制表(VT)</td><td>011</td></tr><tr><td>\ \</td><td>代表一个反斜线字符””</td><td>092</td></tr><tr><td>’</td><td>代表一个单引号（撇号）字符</td><td>039</td></tr><tr><td>“</td><td>代表一个双引号字符</td><td>034</td></tr><tr><td>?</td><td>代表一个问号</td><td>063</td></tr><tr><td>\0</td><td>数字0</td><td>000</td></tr><tr><td>\ddd</td><td>8进制转义字符，d范围0~7</td><td>3位8进制</td></tr><tr><td>\xhh</td><td>16进制转义字符，h范围0<del>9，a</del>f，A~F</td><td>3位16进制</td></tr><tr><td><strong>示例：</strong></td><td></td><td></td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>        <br>        <br>    cout &lt;&lt; <span class="hljs-string">&quot;\\&quot;</span> &lt;&lt; endl;<span class="hljs-comment">//输出单个反斜杠</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;\tHello&quot;</span> &lt;&lt; endl;<span class="hljs-comment">//输出tab</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span> &lt;&lt; endl;<span class="hljs-comment">//输出换行</span><br><br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-6-字符串型"><a href="#1-6-字符串型" class="headerlink" title="1.6 字符串型"></a>1.6 字符串型</h2><p><strong>作用：</strong> 用于表示一串字符<br><strong>两种风格</strong>  </p><ol><li><strong>C风格字符串：</strong> <code>char 变量名[] = &quot;字符串值&quot;</code></li></ol><p>示例  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-type">char</span> str1[] = <span class="hljs-string">&quot;hello world&quot;</span>;<br>    cout &lt;&lt; str1 &lt;&lt; endl;<br>    <br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：C风格的字符串要用双引号括起来<br>2. <strong>C++风格字符串：</strong> <code>string 变量名 = &quot;字符串值&quot;</code><br>示例  </p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    string str = <span class="hljs-string">&quot;hello world&quot;</span>;<br>    cout &lt;&lt; str &lt;&lt; endl;<br>        <br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意：C++风格字符串，需要加入头文件#include<string></p></blockquote><h2 id="1-7-布尔类型-bool"><a href="#1-7-布尔类型-bool" class="headerlink" title="1.7 布尔类型 bool"></a>1.7 布尔类型 bool</h2><p><strong>作用：</strong> 布尔数据类型代表真或假的值<br>bool类型只有两个值：</p><ul><li>true — 真（本质是1）</li><li>false — 假（本质是0）</li></ul><p><strong>bool类型占1个字节大小</strong><br>示例：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>    cout &lt;&lt; flag &lt;&lt; endl; <span class="hljs-comment">// 1</span><br><br>    flag = <span class="hljs-literal">false</span>;<br>    cout &lt;&lt; flag &lt;&lt; endl; <span class="hljs-comment">// 0</span><br>    <span class="hljs-comment">//本质上 1代表真，0代表假</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;size of bool = &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">bool</span>) &lt;&lt; endl; <span class="hljs-comment">//1</span><br>        <br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-8-数据的输入"><a href="#1-8-数据的输入" class="headerlink" title="1.8 数据的输入"></a>1.8 数据的输入</h2><p><strong>作用：</strong> 用于从键盘获取数据<br><strong>关键字</strong> cin<br><strong>语法：</strong> <code>cin &gt;&gt; 变量</code><br>示例：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br>    <span class="hljs-comment">//整型输入</span><br>    <span class="hljs-type">int</span> a = <span class="hljs-number">0</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;请输入整型变量：&quot;</span> &lt;&lt; endl;<br>    cin &gt;&gt; a;<br>    cout &lt;&lt; a &lt;&lt; endl;<br><br>    <span class="hljs-comment">//浮点型输入</span><br>    <span class="hljs-type">double</span> d = <span class="hljs-number">0</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;请输入浮点型变量：&quot;</span> &lt;&lt; endl;<br>    cin &gt;&gt; d;<br>    cout &lt;&lt; d &lt;&lt; endl;<br><br>    <span class="hljs-comment">//字符型输入</span><br>    <span class="hljs-type">char</span> ch = <span class="hljs-number">0</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;请输入字符型变量：&quot;</span> &lt;&lt; endl;<br>    cin &gt;&gt; ch;<br>    cout &lt;&lt; ch &lt;&lt; endl;<br><br>    <span class="hljs-comment">//字符串型输入</span><br>    string str;<br>    cout &lt;&lt; <span class="hljs-string">&quot;请输入字符串型变量：&quot;</span> &lt;&lt; endl;<br>    cin &gt;&gt; str;<br>    cout &lt;&lt; str &lt;&lt; endl;<br><br>    <span class="hljs-comment">//布尔类型输入</span><br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;请输入布尔型变量：&quot;</span> &lt;&lt; endl;<br>    cin &gt;&gt; flag;<span class="hljs-comment">//bool类型 只要是非0的都代表真</span><br>    cout &lt;&lt; flag &lt;&lt; endl;<br>    <span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br>    <span class="hljs-keyword">return</span> EXIT_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C++笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>数据类型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown语法介绍</title>
    <link href="/2024/04/24/Markdown%E8%AF%AD%E6%B3%95%E4%BB%8B%E7%BB%8D/"/>
    <url>/2024/04/24/Markdown%E8%AF%AD%E6%B3%95%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><table><thead><tr><th align="center">功能</th><th align="center">快捷键</th></tr></thead><tbody><tr><td align="center">加粗</td><td align="center">Ctrl + B</td></tr><tr><td align="center">斜体</td><td align="center">Ctrl + I</td></tr><tr><td align="center">引用</td><td align="center">Ctrl + Q</td></tr><tr><td align="center">插入链接</td><td align="center">Ctrl + L</td></tr><tr><td align="center">插入代码</td><td align="center">Ctrl + K</td></tr><tr><td align="center">插入图片</td><td align="center">Ctrl + G</td></tr><tr><td align="center">提升标题</td><td align="center">Ctrl + H</td></tr><tr><td align="center">有序列表</td><td align="center">Ctrl + O</td></tr><tr><td align="center">无序列表</td><td align="center">Ctrl + U</td></tr><tr><td align="center">横线</td><td align="center">Ctrl + R</td></tr><tr><td align="center">撤销</td><td align="center">Ctrl + Z</td></tr><tr><td align="center">重做</td><td align="center">Ctrl + Y</td></tr></tbody></table><p>在vscode中无法使用上述的快捷键，设置的快捷键为vscode中自带的。</p><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="分级标题"><a href="#分级标题" class="headerlink" title="分级标题"></a>分级标题</h2><p>用#表示标题的级别，#后面要加空格</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h3 id="插入本地图片"><a href="#插入本地图片" class="headerlink" title="插入本地图片"></a>插入本地图片</h3><h4 id="插入同级目录下的图片"><a href="#插入同级目录下的图片" class="headerlink" title="插入同级目录下的图片"></a>插入同级目录下的图片</h4><pre><code class="hljs">！[图片描述](/pic.jpg)</code></pre><h4 id="插入下一级目录下的图片"><a href="#插入下一级目录下的图片" class="headerlink" title="插入下一级目录下的图片"></a>插入下一级目录下的图片</h4><pre><code class="hljs">！[图片描述](/pics/pic2.jpg)</code></pre><p>图片描述可以不写</p><h3 id="插入互联网上的图片"><a href="#插入互联网上的图片" class="headerlink" title="插入互联网上的图片"></a>插入互联网上的图片</h3><pre><code class="hljs">！[图片描述](https://pic.downcc.com/upload/2015-9/2015923174024.png)</code></pre><h3 id="自动连接"><a href="#自动连接" class="headerlink" title="自动连接"></a>自动连接</h3><p>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用&lt;&gt;包起来， Markdown 就会自动把它转成链接。也可以直接写，也是可以显示成链接形式的</p><h2 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h2><p>可以在一行中用三个以上的星号(*)、减号(-)、底线(_)来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格</p><hr><p>分隔一</p><hr><p>分隔二</p><hr><p>分隔三</p><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>插入程序代码的方式有两种，一种是利用缩进(tab), 另一种是利用英文“&#96;”符号</p><h3 id="代码块-1"><a href="#代码块-1" class="headerlink" title="代码块"></a>代码块</h3><p>缩进 4 个空格或是 1 个制表符。</p><h3 id="行内式"><a href="#行内式" class="headerlink" title="行内式"></a>行内式</h3><p>如果在一个行内需要引用代码，只要用反引号&#96;引起来就好</p><h3 id="多行代码块与语法高亮"><a href="#多行代码块与语法高亮" class="headerlink" title="多行代码块与语法高亮"></a>多行代码块与语法高亮</h3><p>在需要高亮的代码块的前一行及后一行使用三个单反引号“&#96;”包裹，就可以了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">i</span> am <span class="hljs-selector-tag">code</span><br></code></pre></td></tr></table></figure><h3 id="代码块里面包含html代码"><a href="#代码块里面包含html代码" class="headerlink" title="代码块里面包含html代码"></a>代码块里面包含html代码</h3><p>在代码区块里面， &amp; 、 &lt; 和 &gt; 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，剩下的 Markdown 都会帮你处理。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>在被引用的文本前加上&gt;符号，以及一个空格就可以<br>可以用多个&gt;进行嵌套引用</p><blockquote><p>eqhueudq</p><blockquote><p>d1</p><blockquote><p>fwe</p></blockquote></blockquote></blockquote><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>使用 *，+，- 表示无序列表</p><ul><li>列表文字1</li></ul><ul><li>列表文字2</li></ul><ul><li>列表文字3</li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>使用数字和一个英文句点表示有序列表。</p><ol><li>列表文字1</li><li>列表文字2</li><li>列表文字3</li></ol><h3 id="无序列表和有序列表同时使用"><a href="#无序列表和有序列表同时使用" class="headerlink" title="无序列表和有序列表同时使用"></a>无序列表和有序列表同时使用</h3><ul><li><ol><li>列表文字1</li></ol></li></ul><ul><li><ol start="2"><li>列表文字2</li></ol></li></ul><p>在使用列表时，只要是数字后面加上英文的点，就会无意间产生列表，比如2017.12.30 这时候想表达的是日期，有些软件把它被误认为是列表。解决方式：在每个点前面加上\就可以了</p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>用-和|创建表格，如快捷键模块</p><h2 id="常用技巧"><a href="#常用技巧" class="headerlink" title="常用技巧"></a>常用技巧</h2><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><p>方法1: 连续两个以上空格+回车  </p><p>方法2：使用html语言换行标签：</p><h3 id="缩进字符"><a href="#缩进字符" class="headerlink" title="缩进字符"></a>缩进字符</h3><p>不断行的空白格   或  半角的空格   或  全角的空格   或  <br>&amp;nbsp缩进缩进  </p><p>没看懂</p><h3 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h3><p>对于 Markdown 中的语法符号，前面加反斜线\即可显示符号本身。  </p><p>其他特殊字符，示例如下：<br>&#10084;<br>&#10003;<br>&#9728;<br>&#9733;<br>&#9730;<br>&#9742;<br>其他的特殊字符可以在这个网站上查看 <a href="https://unicode-table.com/cn/">https://unicode-table.com/cn/</a></p><h3 id="字体、字号与颜色"><a href="#字体、字号与颜色" class="headerlink" title="字体、字号与颜色"></a>字体、字号与颜色</h3><p>Markdown是一种可以使用普通文本编辑器编写的标记语言，通过类似HTML的标记语法，它可以使普通文本内容具有一定的格式</p><h3 id="Latex数学公式"><a href="#Latex数学公式" class="headerlink" title="Latex数学公式"></a>Latex数学公式</h3><h4 id="行内公式"><a href="#行内公式" class="headerlink" title="行内公式"></a>行内公式</h4><p>使用两个”$”符号引用公式:<br>$J\begin{pmatrix}t\end{pmatrix}&#x3D;A\exp\begin{pmatrix}j\begin{pmatrix}2\pi f_ct+\varphi\end{pmatrix}\end{pmatrix}$</p><h4 id="行间公式"><a href="#行间公式" class="headerlink" title="行间公式"></a>行间公式</h4><p>使用两对“$$”符号引用公式<br>$$<br>b_k\begin{pmatrix}t\end{pmatrix}&#x3D;\sum_{n&#x3D;0}^\infty b_ng_b\begin{pmatrix}t-nT_b\end{pmatrix}<br>$$</p>]]></content>
    
    
    <categories>
      
      <category>博客相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开始hexo_Fluid博客编写</title>
    <link href="/2024/04/16/%E5%BC%80%E5%A7%8Bhexo-Fluid%E5%8D%9A%E5%AE%A2%E7%BC%96%E5%86%99/"/>
    <url>/2024/04/16/%E5%BC%80%E5%A7%8Bhexo-Fluid%E5%8D%9A%E5%AE%A2%E7%BC%96%E5%86%99/</url>
    
    <content type="html"><![CDATA[<h2 id="开始一个博客"><a href="#开始一个博客" class="headerlink" title="开始一个博客"></a>开始一个博客</h2><p>在本地创建的文件夹中（例如myblog），右键git bash here，打开命令行窗口后即可开始操作。<br>ping不上github所以更改端口为7890（clash默认端口），每次必须要打开clash才能部署文章到github上。</p><h2 id="hexo命令"><a href="#hexo命令" class="headerlink" title="hexo命令"></a>hexo命令</h2><h3 id="新建一篇文章"><a href="#新建一篇文章" class="headerlink" title="新建一篇文章"></a>新建一篇文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;文章标题&quot;</span><br></code></pre></td></tr></table></figure><p>这将会在Hexo博客的 source&#x2F;_posts 目录下创建一个名为 文章标题.md 的Markdown文件。可以使用任何文本编辑器打开这个文件，然后开始编写文章内容。</p><p>每次更改完成之后最好先清除之前生成的内容。</p><h3 id="清除之前生成的内容"><a href="#清除之前生成的内容" class="headerlink" title="清除之前生成的内容"></a>清除之前生成的内容</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo clean<br></code></pre></td></tr></table></figure><p>本地预览生成后访问<a href="http://localhost:4000/">http://localhost:4000/</a> 即可查看</p><h3 id="生成本地预览"><a href="#生成本地预览" class="headerlink" title="生成本地预览"></a>生成本地预览</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo s<br></code></pre></td></tr></table></figure><h3 id="生成静态文章"><a href="#生成静态文章" class="headerlink" title="生成静态文章"></a>生成静态文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>部署文章可能会有延迟，以本地预览效果为准</p><h3 id="部署文章"><a href="#部署文章" class="headerlink" title="部署文章"></a>部署文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>博客相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
